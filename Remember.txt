WORKDIR /usr/src/app
Docker containers work on Linux so we use linux file system convention



build: .
//Dockerfile is in the current directory so we use a fullstop to denote that



docker compose run --service-ports web bash //enter




go get github.com/fiber/v2






COPY . . 
// will copy all our files fromt he host to the conatiner







RUN go mod tidy
//ensure that all our packages are properly installed









version: '3.8'

services:
  web:
    build: .
    ports:
      - 3000:3000
    volumes:
      - .:/usr/src/app
    command: go run cmd/main.go -b 0.0.0.0  




docker compose run --service-ports web bash
//enter





root@64c5b1a67d2e:/usr/src/app# exit
//exit






 docker compose up
 will run the go fiber web server by typing
 docker compose up
 because of this
 command: go run cmd/main.go -b 0.0.0.0









 With go we need to rebuild our project in order to see the changes






 //dockerfile
 installl a package called air using command
 RUN go install github.com/cosmtrek/air@latest







 we also need a config file for the air package
 .air.toml








 paste in .air.toml from github.com/cosmtrek/air








cmd = "go build -o ./tmp/main ."
make this change
 cmd = "go build -o ./tmp/main ./cmd"
 because or main.go is in cmd





command: go run cmd/main.go -b 0.0.0.0
  change to 
  command: air cmd/main.go -b 0.0.0.0
  for air

 
 
 
 
 
 
 
 
 
 
 PS D:\editor compiler files etc\Dev\go-postgres-docker> docker compose build
 because we have made changes to dockerfile instructions








db:
    image: postgres:alpine 
    //we can pull directly from dockerhub






ports: -5432:5432
This is the port typically used by postgres







volumes:
  postgres-db:
This is a "Named volume" so that our postgres data so that any removals have to be done manually












version: '3.8'

services:
  web:
    build: .
    env_file:
      - .env
    ports:
      - 3000:3000
    volumes:
      - .:/usr/src/app
    command: air cmd/main.go -b 0.0.0.0
  db:
    image: postgres:alpine
    environment:
      - POSTGRES_USER=$(DB_USER)
      - POSTGRES_PASSWORD=$(DB_PASSWORD)
      - POSTGRES_NAME=$(DB_NAME)
    ports: -5432:5432
    volumes: -postgres-db:/var/lib/postgresql/data

volumes:
  postgres-db:








ORM library called GORM
go get gorm.io/gorm









gorm supports several databases so we need to install the postgres driver
go get gorm.io/gorm






advantages of using an ORM library is that it allows us to manipulate data from a database in an object-oriented way
These objects can also be described as models







create models/models.go






`json:"question"
`json:"answer"
JSON struct tags with lowercase JSON keys for each of our struct fields








gorm:"text;not null;default:null"`
gorm:"text;not null;default:null"`
also added GORM struct tags to our fact fields
we set the value for both colums to be null so that it throws an error when the user leaves a field empty








gorm.OPEN()
takes 2 arguments,
the first argument will be a GORM dialector, it will be related to postgres
the second argument will be some option
gorm.OPEN(gorm_dialector, gorm_options)

for our dialector we will use postgres.Open() method
gorm.Open(postgres.Open(dsn), gorm_options)
also import the postgres driver




dsn(datasource name string)








package database

import "gorm.io/gorm"

import "gorm.io/driver/postgres"

type Dbinstance struct{
	Db *gorm.DB
}

var DB Dbinstance

func ConnectDb(){  
	
  gorm.Open(postgres.Open(dsn), gorm_options)

}









package database

import "gorm.io/gorm"

import "gorm.io/driver/postgres"


type Dbinstance struct{
	Db *gorm.DB
}

var DB Dbinstance

func ConnectDb(){

    dsn := fmt.Sprint(
    "host=db user=%s password=%s dbname=%s port=5432 sslmode=disable TimeZone=Asia/Shanghai", 
	os.Getenv("DB_USER"),
	os.Getenv("DB_PASSWORD"),
	os.Getenv("DB_NAME"),
)

	gorm.Open(postgres.Open(dsn), gorm_options)
}










package database

import "gorm.io/gorm"

import "gorm.io/driver/postgres"

import "fmt"

import "os"

type Dbinstance struct{
	Db *gorm.DB
}

var DB Dbinstance

func ConnectDb(){

    dsn := fmt.Sprint(
    "host=db user=%s password=%s dbname=%s port=5432 sslmode=disable TimeZone=Asia/Shanghai", 
	os.Getenv("DB_USER"),
	os.Getenv("DB_PASSWORD"),
	os.Getenv("DB_NAME"),
)

	gorm.Open(postgres.Open(dsn), gorm_options)
}










pointer &gorm.Config{}








package database

import (

	"gorm.io/gorm"

	"gorm.io/driver/postgres"

	"fmt"

	"os"

	"gorm.io/gorm/logger"

	
)

type Dbinstance struct{
	Db *gorm.DB
}

var DB Dbinstance

func ConnectDb(){

    dsn := fmt.Sprintf(
    "host=db user=%s password=%s dbname=%s port=5432 sslmode=disable TimeZone=Asia/Shanghai", 
	os.Getenv("DB_USER"),
	os.Getenv("DB_PASSWORD"),
	os.Getenv("DB_NAME"),
)

	gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	})

	
}













package database

import (

	"gorm.io/gorm"

	"gorm.io/driver/postgres"

	"fmt"

	"os"

	"gorm.io/gorm/logger"

    "log"	

	"github.com/1bhavyasingh1/REST/models"
)

type Dbinstance struct{
	Db *gorm.DB
}

var DB Dbinstance

func ConnectDb(){

    dsn := fmt.Sprintf(
    "host=db user=%s password=%s dbname=%s port=5432 sslmode=disable TimeZone=Asia/Shanghai", 
	os.Getenv("DB_USER"),
	os.Getenv("DB_PASSWORD"),
	os.Getenv("DB_NAME"),
)

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	})
    
    if err != nil {
		log.Fatal("Failed to connect to database, \n", err)
		os.Exit(2)
	}

	log.Println("connected")
	db.Logger = logger.Default.LogMode(logger.Info)

	log.Println("running migrations")
	db.AutoMigrate(&models.Fact{})

	DB = Dbinstance{
		Db: db, 
	}
}










database.ConnectDb()
calling connectDb function from database.go








touch cmd/routes.go 







app.Get("/", func(c *fiber.Ctx) error {
        return c.SendString("Hello,!")
    })

//copy from main.go

import (
    "github.com/gofiber/fiber/v2"
    "github.com/1bhavyasingh1/REST/database"
)

func main() {
    database.ConnectDb()
    app := fiber.New()

    setupRoutes(app)

    app.Get("/", func(c *fiber.Ctx) error {
        return c.SendString("Hello,!")
    })
    
    app.Listen(":3000")
}

paste in routes.go    










create handlers folder
create handlers/facts.go








func Home(c *fiber.Ctx) error {
	
}
all handlers take in the Gofiber context as argument and return an error









copy 
	return c.SendString("Hello,!")
from routes.go
  package main

  import "github.com/gofiber/fiber/v2"


  func setupRoutes(app *fiber.App){
	  app.Get("/", func(c *fiber.Ctx) error {
          return c.SendString("Hello,!")
      })
  }
and paste in facts.go 






make changes in routes.go

package main

import (
    "github.com/gofiber/fiber/v2"
    "github.com/1bhavyasingh1/REST/handlers"
)


func setupRoutes(app *fiber.App){
	app.Get("/", handlers.Home) 
}









if err := c.BodyParser(fact); err != nil {
  The BodyParser function returns an error







routes.go
app.Post("/fact", handlers.Facts) 
facts.go
func Facts(c *fiber.Ctx) error {
	facts := []models.Fact{}
	database.DB.Db.Find(&facts)

	return c.Status(200).JSON(facts)
}












return c.Status(200).JSON(facts)
we return a success status code 200 and all are facts formatted as JSON